{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c7b025d2b999b63539cedb30fa25d00f150b958a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/RoomFactory.sol": "project/contracts/RoomFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Room.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract Room {\n    enum RoomStatus { Active, Expired, Finalized }\n    \n    struct WorkoutSession {\n        address participant;\n        uint256 repCount;\n        uint256 formScore; // 0-100 scale\n        uint256 timestamp;\n        bytes signature;\n        string sessionData; // JSON with pose data for verification\n    }\n    \n    address public creator;\n    string public exerciseType;\n    uint256 public stakeAmount;\n    uint256 public duration;\n    uint256 public createdAt;\n    uint256 public endTime;\n    string public exerciseConfig; // JSON with angles, landmarks for transparency\n    RoomStatus public status;\n\n    mapping(address => bool) public hasSubmitted;\n    WorkoutSession[] public sessions;\n    \n    \n    event WorkoutSubmitted(address indexed participant, uint256 repCount, uint256 formScore);\n    event RoomFinalized(address[] winners, uint256[] rewards);\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, \"Only creator can call this\");\n        _;\n    }\n    \n    modifier onlyActive() {\n        require(status == RoomStatus.Active, \"Room not active\");\n        require(block.timestamp < endTime, \"Room expired\");\n        _;\n    }\n    \n    modifier onlyExpired() {\n        require(block.timestamp >= endTime || status == RoomStatus.Expired, \"Room not expired\");\n        _;\n    }\n\n    constructor(\n        address _creator,\n        string memory _exerciseType,\n        uint256 _stakeAmount,\n        uint256 _duration,\n        string memory _exerciseConfig\n    ) payable {\n        require(msg.value == _stakeAmount, \"Creator must stake the required amount\");\n        \n        creator = _creator;\n        exerciseType = _exerciseType;\n        stakeAmount = _stakeAmount;\n        duration = _duration;\n        exerciseConfig = _exerciseConfig;\n        createdAt = block.timestamp;\n        endTime = createdAt + _duration;\n        status = RoomStatus.Active;\n    }\n\n    function submitWorkout(\n        uint256 repCount,\n        uint256 formScore,\n        bytes calldata signature,\n        string calldata sessionData\n    ) external payable onlyActive {\n        require(msg.value == stakeAmount, \"Must stake the required amount\");\n        require(!hasSubmitted[msg.sender], \"Already submitted workout\");\n        require(formScore <= 100, \"Form score must be 0-100\");\n        \n        // TODO: Add signature verification for session data\n        // For MVP, we'll trust the client-side signing\n        \n        WorkoutSession memory session = WorkoutSession({\n            participant: msg.sender,\n            repCount: repCount,\n            formScore: formScore,\n            timestamp: block.timestamp,\n            signature: signature,\n            sessionData: sessionData\n        });\n        \n        sessions.push(session);\n        hasSubmitted[msg.sender] = true;\n        \n        emit WorkoutSubmitted(msg.sender, repCount, formScore);\n    }\n\n    function finalizeRoom() external onlyCreator onlyExpired {\n        require(status != RoomStatus.Finalized, \"Room already finalized\");\n        \n        status = RoomStatus.Finalized;\n        \n        // Simple reward calculation for MVP\n        uint256 totalReward = address(this).balance;\n        \n        if (sessions.length == 0) {\n            // No sessions, refund creator\n            payable(creator).transfer(totalReward);\n            emit RoomFinalized(new address[](0), new uint256[](0));\n            return;\n        }\n        \n        // Find best session (highest score)\n        uint256 bestScore = 0;\n        address winner = address(0);\n        \n        for (uint256 i = 0; i < sessions.length; i++) {\n            uint256 score = sessions[i].repCount * sessions[i].formScore;\n            if (score > bestScore) {\n                bestScore = score;\n                winner = sessions[i].participant;\n            }\n        }\n        \n        // For MVP, winner takes all (we can enhance this later)\n        if (winner != address(0)) {\n            payable(winner).transfer(totalReward);\n            \n            address[] memory winners = new address[](1);\n            uint256[] memory rewards = new uint256[](1);\n            winners[0] = winner;\n            rewards[0] = totalReward;\n            \n            emit RoomFinalized(winners, rewards);\n        }\n    }\n\n    function getParticipants() external view returns (address[] memory) {\n        // Return unique participants from sessions\n        address[] memory participants = new address[](sessions.length);\n        for (uint256 i = 0; i < sessions.length; i++) {\n            participants[i] = sessions[i].participant;\n        }\n        return participants;\n    }\n    \n    function getParticipantCount() external view returns (uint256) {\n        return sessions.length;\n    }\n    \n    function getSessions() external view returns (WorkoutSession[] memory) {\n        return sessions;\n    }\n    \n    function getRoomStatus() external view returns (\n        RoomStatus roomStatus,\n        uint256 participantCount,\n        uint256 totalStaked,\n        uint256 timeRemaining\n    ) {\n        roomStatus = status;\n        participantCount = sessions.length;\n        totalStaked = address(this).balance;\n        \n        if (block.timestamp >= endTime) {\n            timeRemaining = 0;\n        } else {\n            timeRemaining = endTime - block.timestamp;\n        }\n    }\n}"
      },
      "project/contracts/RoomFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./Room.sol\";\n\ncontract RoomFactory {\n    event RoomCreated(\n        address indexed roomAddress,\n        address indexed creator,\n        string exerciseType,\n        uint256 stakeAmount,\n        uint256 duration,\n        uint256 indexed roomId\n    );\n\n    struct RoomInfo {\n        address roomAddress;\n        address creator;\n        string exerciseType;\n        uint256 stakeAmount;\n        uint256 duration;\n        uint256 createdAt;\n        bool active;\n    }\n\n    mapping(uint256 => RoomInfo) public rooms;\n    mapping(address => uint256[]) public userRooms;\n    uint256 public nextRoomId;\n\n    function createRoom(\n        string calldata exerciseType,\n        uint256 stakeAmount,\n        uint256 duration,\n        string calldata exerciseConfig // JSON string with angles, landmarks for transparency\n    ) external payable returns (address roomAddress, uint256 roomId) {\n        require(msg.value == stakeAmount, \"Must stake the required amount\");\n        require(duration > 0, \"Duration must be greater than 0\");\n        require(bytes(exerciseType).length > 0, \"Exercise type required\");\n\n        roomId = nextRoomId++;\n        \n        Room newRoom = new Room{value: msg.value}(\n            msg.sender,\n            exerciseType,\n            stakeAmount,\n            duration,\n            exerciseConfig\n        );\n        \n        roomAddress = address(newRoom);\n        \n        rooms[roomId] = RoomInfo({\n            roomAddress: roomAddress,\n            creator: msg.sender,\n            exerciseType: exerciseType,\n            stakeAmount: stakeAmount,\n            duration: duration,\n            createdAt: block.timestamp,\n            active: true\n        });\n        \n        userRooms[msg.sender].push(roomId);\n        \n        emit RoomCreated(roomAddress, msg.sender, exerciseType, stakeAmount, duration, roomId);\n    }\n\n    function getRoomInfo(uint256 roomId) external view returns (RoomInfo memory) {\n        return rooms[roomId];\n    }\n\n    function getUserRooms(address user) external view returns (uint256[] memory) {\n        return userRooms[user];\n    }\n\n    function getAllActiveRooms() external view returns (uint256[] memory) {\n        uint256[] memory activeRooms = new uint256[](nextRoomId);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < nextRoomId; i++) {\n            if (rooms[i].active) {\n                activeRooms[count] = i;\n                count++;\n            }\n        }\n        \n        // Resize array to actual count\n        uint256[] memory result = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = activeRooms[i];\n        }\n        \n        return result;\n    }\n}"
      }
    }
  }
}